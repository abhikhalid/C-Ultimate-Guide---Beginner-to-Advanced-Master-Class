using System;
using System.Threading;

namespace Manual_Reset_Event
{
   class Shared
    {
        //Store data values generated by producer thread
        public static int[] Data { get; set; }

        //Total number of values
        public static int BatchCount { get; set; }

        public static int BatchSize { get; set; }

        public static AutoResetEvent Event{ get; set; }

        static Shared()
        {
            Data = new int[15];
            BatchCount = 5;
            BatchSize = 3;
            Event = new AutoResetEvent(false); //unsignaled (false)
        }
    }

    //Represents producer thread
    class Producer
    {
        //Thread method for Producer Thread
        public void Produce()
        {
            Console.WriteLine($"{Thread.CurrentThread.Name} started");

            for (int i = 0; i < Shared.BatchCount; i++) //5 times
            {
                //Generate some data and store it in the Data array.
                for (int j = 0; j < Shared.BatchSize; j++) // 3 times
                {
                    Shared.Data[i * Shared.BatchSize + j] = (i * Shared.BatchSize) + j + 1;
                    Thread.Sleep(300); // Simulating artificial delay.
                }
                //now, we can not talk to Consumer Thread Directly.
                //Set the signal (signal that the producer has finished generating data)

                //Consumer Thread is waiting for this exact moment.
                Shared.Event.Set();
                

                //AutoResetEvent allows one waiting thread to proceed, and immediately rsets the event to "unsignaled".
                //So, an explicit reset is not required.

                //Reset the signal (makes the consumer thread wait for signal before reading next batch)
               // Shared.Event.Reset();
            }

           

            Console.WriteLine($"{Thread.CurrentThread.Name} completed");
        }
    }

    //Represents consumer thread
    class Consumer
    {
        //Consume method for Consumer Thread
        public void Consume()
        {
            Console.WriteLine($"{Thread.CurrentThread.Name} started");
            Console.WriteLine("Consumer is waiting for producer thread to finish generating data");

            for(int i=0; i< Shared.BatchCount; i++)
            {
                Shared.Event.WaitOne(); //consumer thread waits until the status of event becomes singnaled.

                Console.WriteLine("Consumer Thread has received a signal from the Producer Thread");

                //Read Data
                Console.WriteLine("\nData is");

                for (int j = 0; j < Shared.BatchSize; j++)
                {
                    Console.WriteLine(Shared.Data[i * Shared.BatchSize + j]);
                }
            }

            Console.WriteLine($"{Thread.CurrentThread.Name} completed");
        }

    }

    class Program
    {
        static void Main()
        {
            //create objects of Producer and Consumer classes.
            Producer producer = new Producer();

            Consumer consumer = new Consumer();

            //craete delegate objects of ThreadStart
            ThreadStart threadStart1 = new ThreadStart(producer.Produce);
            ThreadStart threadStart2 = new ThreadStart(consumer.Consume);

            //create thread objects
            Thread producerThread = new Thread(threadStart1)
            {
                Name = "Producer Thread"
            };
            Thread consumerThread = new Thread(threadStart2)
            {
                Name = "Consumer Thread"
            };

            //Start threads
            producerThread.Start();
            consumerThread.Start();

            //Join both threads to main thread
            producerThread.Join();
            consumerThread.Join();  

            Console.ReadKey();
        }
    }
}
